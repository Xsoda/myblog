.. 漂亮的原生库

.. post:: Nov 28, 2015
   :tags: native-library, programming, translation
   :author: Xsoda

漂亮的原生库
================

   本文翻译自：http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/

我对漂亮的API着迷，不仅仅是API本身，还在于尽可能好的使用一个库的全部体验。对于\ ``Python``\ 来
说现在有很多的最好实践，但是感觉并没有大量信息来说明如何正确地构造一个原生库。我说的原生库指的是
什么？本质上是一个\ ``dylib/DLL/so``\ 文件。

由于我最近的工作中在C和C++上花了比Python还多的时间，我想通了如何写出合适的共享库而不惹恼库的使用
者，借这个机会整理一些我的想法。

共享库还是静态库？
------------------------

这篇文章几乎假定了你正在构建一个\ ``DLL``\ 或共享库而不是你链接的静态库。虽然听起来动态链接和静态
链接本质是同样的，唯一的区别是你如何链接到它，当然远不止于此。

使用动态链接库你可以更好地控制你的符号，在不同的编程语言中也可以更好的工作。你使用C++编写一个库然后
在Python中使用也是可以的。实际上，我建议对这些库做单元测试的方法是完成正确的，稍后谈的更多。

使用哪一种语言？
------------------

你想写的库在编译成DLL或类似东西后，应该有些是平台独立的。现实中你可以用哪一种语言呢？目前你可以在
C和C++中选择，很快你可能也可以使用Rust。为什么不用其他的呢？C语言在实际中是唯一能定义稳定ABI的。
严谨来说，不是语言来定义它，而是操作系统，从另一方面看，C是库所选择的语言并且C的调用约定是共享库的
通用方式。

“最伟大的魔术是C说服世界相信它并没有运行时”。我不确定我在哪儿第一次听到这句话，但是当谈论库时它非
常合适。实质上C是如此普遍，任何事都可以假定为C标准库提供的基本函数，这是大家都同意的。对于C++情况变
得更复杂。C++需要额外的函数来支持异常处理，这些函数在C标准库里并没提供。C++能够很好的降级到C调用约定，
所有可以很容易地用它写库，可以完整的隐藏库由C++编写这一事实。

对于其他语言来说无乱怎样都不是那么容易。例如为什么使用Go语言来写一个库并不是一个好注意呢？原因是Go需要
相当重量级的运行时来做垃圾收集和提供协程调度。Rust正在接近与除C标准库外不需要运行时，这将使得用它来
编写库是可能的。

然而现在C++是你最可能要使用的语言。为什么不是C呢？原因是微软的C编译器在接受语言更新方面声名狼藉，你只能
使用C89标准。显然你也可以在Windows上使用不同的编译器，但是这将会对库的使用者在编译库时造成很多问题。
需要非原生的操作系统工具链是疏远开发者受众的简单方式。

我通常建议使用非常像C的C++子集：不使用异常，不使用RTTI，不要写令人发狂的构造函数。文章的余下部分
假定C++是我们真正选择的语言。

公共头文件
-----------------

你构建的库应该只有一个精确的公共头文件。而内部无乱你想有多少个头文件都可以，有了唯一的头文件，即使
你的库去链接不是C语言的东西都可以。以Python为例，CFFI库可以解析头文件并且建立符号绑定。使用各种语言
的人知道头文件如何工作，他们会看一看建立自己的绑定。

头文件应该遵循什么规则呢？

头文件守卫
```````````

提供其他人使用的每一个头文件应该最大限度的使用唯一的头文件守卫标记来确保他们可以安全的被包含多次。
守卫表记不用太有创新，但也别太普通。包含一个在顶部使用一个超级通用的包含守卫（例如\ ``UTILS_H``\ 或其他）
的头文件并不有趣。你也想在C++文件包含时确保有\ ``extern "C"``\ 标记。

下面是你的最小头文件：

.. code-block:: c
   :linenos:

   #ifndef YOURLIB_H_INCLUDED
   #define YOURLIB_H_INCLUDED
   #ifdef __cplusplus
   extern "C" {
   #endif

   /* code goes here */

   #ifdef __cplusplus
   }
   #endif
   #endif

导出符号标记
````````````````````

因为你自己将可能包含你的头文件，同样你也需要确保导出函数的宏被定义。在Windows上这是必要的，并且在其他平台上
也是一个不错的主意。实质上导出符号标记用来改变符号的可视性。稍后我再讲他们，现在仅仅把下面的代码添加进去：

.. code-block:: c
   :linenos:

   #ifndef YL_API
   #  ifdef _WIN32
   #     if defined(YL_BUILD_SHARED) /* build dll */
   #         define YL_API __declspec(dllexport)
   #     elif !defined(YL_BUILD_STATIC) /* use dll */
   #         define YL_API __declspec(dllimport)
   #     else /* static library */
   #         define YL_API
   #     endif
   #  else
   #     if __GNUC__ >= 4
   #         define YL_API __attribute((visibility("default")))
   #     else
   #         define YL_API
   #     endif
   #  endif
   #endif

在Windows上将为DLL妥善的设置\ ``YL_API``\ （我这里使用"Your Library"的缩写版本，你可以挑选一个适合你的前缀），
这取决与哪一个标志被设置。无论谁包含了头文件而什么也不做将自动获得\ ``__declspec(dllimport)``\ 。在Windows下
这是很好的默认行为。对于其他平台什么也不设置除非是用的是最近被添加了默认符号可视性的GCC/clang版本。你可以看到
一些宏定义后，改变了编译器使用的分支。例如当你构建库本身时，你可以定义\ ``YL_BUILD_SHARED``\ 来告诉编译器。

在Windows上DLL的默认行为总是：所有的符号并不会被导出，除非使用\ ``__declspec(dllexport)``\ 标记。不幸的是，
在其他平台上编译器的行为总是导出任何符号。有很多的方法来修复它，其一就是控制GCC 4的可视性。这可以很好的工作，
但是还有一下额外的事需要考虑。

第一就是在源代码上的可视性控制并不是银弹。刚开始标记将什么也不做除非库使用了\ ``--fvisibility=hidden``\ 。
更重要是这只对你自己的库有影响。如果你静态链接到你的库，而这个库却暴露了你并不想暴露的符号。设想一下，你写了
一个库，而这个库依赖与其他你想要静态链接的库。这个库的符号将也会从你的库导出，必须阻止这样的事发生。

这个工作在不同的平台而不同。Linux下你可以传递\ ``--exclude-libs ALL``\ 给\ ``ld``\ ，然后链接器将会
自动移除这些符号。OS X下是一个骗子，因为链接器没有符合的功能。最简单的解决方案是为所有的函数使用一个公共前缀。
在本例中如果你所有的函数都以\ ``yl_``\ 开头，告诉链接器隐藏其他的符号就简单了。你创建符号文件然后给链接器指明
参数\ ``-exported_symbols_list symbols.txt``\ ，文件的内容可以是单独的一行\ ``_yl_*``\ 。
Windows下我们可以忽略因为DLL需要显式的导出标记。

小心地包含和定义
---------------------

稳定的ABI
-------------

导出为C语言API
------------------

对象上下文
----------------

客户化内存分配
-----------------

内存分配和C++
------------------

内存分配失败
-----------------

构建
---------

测试
---------

总结
----------
