.. 漂亮的原生库

.. post:: Nov 28, 2015
   :tags: native-library, programming, translation
   :author: Xsoda

漂亮的原生库
================

   本文翻译自: http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/

我对漂亮的API着迷，不仅仅是API本身，还在于尽可能好的使用一个库的全部体验。对于\ ``Python``\ 来说现在有很多的最好实践，
但是感觉并没有大量信息来说明如何正确地构造一个原生库。我说的原生库指的是什么？本质上是一个\ ``dylib/DLL/so``\ 文件。

由于我最近的工作中在C和C++上花了比Python还多的时间，我想通了如何写出合适的共享库而不惹恼库的使用者，借这个机会整理一些我的想法。

共享库还是静态库？
------------------------

这篇文章几乎假定了你正在构建一个\ ``DLL``\ 或共享库而不是你链接的静态库。虽然听起来动态链接和静态链接本质是同样的，唯一的区别是你如何链接到它，当然远不止于此。

使用动态链接库你可以更好地控制你的符号，在不同的编程语言中也可以更好的工作。你使用C++编写一个库然后在Python中使用也是可以的。实际上，我建议对这些库做单元测试的方法是完成正确的，稍后谈的更多。

使用哪一种语言？
------------------

你想写的库在编译成DLL或类似东西后，应该有些是平台独立的。现实中你可以用哪一种语言呢？目前你可以在C和C++中选择，很快你可能也可以使用Rust。为什么不用其他的呢？C语言在实际中是唯一能定义稳定ABI的。严谨来说，不是语言来定义它，而是操作系统，从另一方面看，C是库所选择的语言并且C的调用约定是共享库的通用方式。

“最伟大的魔术是C说服世界相信它并没有运行时”。我不确定我在哪儿第一次听到这句话，但是当谈论库时它非常合适。实质上C是如此普遍，任何事都可以假定为C标准库提供的基本函数，这是大家都同意的。对于C++情况变得更复杂。C++需要额外的函数来支持异常处理，这些函数在C标准库里并没提供。C++能够很好的降级到C调用约定，所有可以很容易地用它写库，可以完整的隐藏库由C++编写这一事实。

对于其他语言来说无乱怎样都不是那么容易。例如为什么使用Go语言来写一个库并不是一个好注意呢？原因是Go需要相当重量级的运行时来做垃圾收集和提供协程调度。Rust正在接近与除C标准库外不需要运行时，这将使得用它来编写库是可能的。

然而现在C++是你最可能要使用的语言。为什么不是C呢？原因是微软的C编译器在接受语言更新方面声名狼藉，你只能使用C89标准。显然你也可以在Windows上使用不同的编译器，但是这将会对库的使用者在编译库时造成很多问题。需要非原生的操作系统工具链是疏远开发者受众的简单方式。

我通常建议使用非常像C的C++子集：不使用异常，不使用RTTI，不要写令人发狂的构造函数。文章的余下部分假定C++是我们真正选择的语言。

公共头文件
-----------------

你构建的库应该只有一个精确的公共头文件。而内部无乱你想有多少个头文件都可以，有了唯一的头文件，即使你的库去链接不是C语言的东西都可以。以Python为例，CFFI库可以解析头文件并且建立符号绑定。使用各种语言的人知道头文件如何工作，他们会看一看建立自己的绑定。

头文件应该遵循什么规则呢？

头文件守卫
```````````

提供其他人使用的每一个头文件应该最大限度的使用唯一的头文件守卫标记来确保他们可以安全的被包含多次。守卫表记不用太有创新，但也别太普通。包含一个在顶部使用一个超级通用的包含守卫（例如\ ``UTILS_H``\ 或其他）的头文件并不有趣。你也想在C++文件包含时确保有\ ``extern "C"``\ 标记。

下面是你的最小头文件：

.. code-block::
   :language: c
   :linenos:

   #ifndef YOURLIB_H_INCLUDED
   #define YOURLIB_H_INCLUDED
   #ifdef __cplusplus
   extern "C" {
   #endif

   /* code goes here */

   #ifdef __cplusplus
   }
   #endif
   #endif

导出符号标记
````````````````````

因为你自己将可能包含你的头文件，同样你也需要确保导出函数的宏被定义。在Windows上这是必要的，并且在其他平台上也是一个不错的主意。实质上导出符号标记用来改变符号的可视性。稍后我再讲他们，现在仅仅把下面的代码添加进去：

.. code-block::
   :language: c
   :linenos:

   #ifndef YL_API
   #  ifdef _WIN32
   #     if defined(YL_BUILD_SHARED) /* build dll */
   #         define YL_API __declspec(dllexport)
   #     elif !defined(YL_BUILD_STATIC) /* use dll */
   #         define YL_API __declspec(dllimport)
   #     else /* static library */
   #         define YL_API
   #     endif
   #  else
   #     if __GNUC__ >= 4
   #         define YL_API __attribute((visibility("default")))
   #     else
   #         define YL_API
   #     endif
   #  endif
   #endif
